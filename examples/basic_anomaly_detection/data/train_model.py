"""
Train and convert a simple autoencoder model for anomaly detection.

This script demonstrates how to:
1. Generate synthetic sensor data
2. Train an autoencoder model
3. Convert the model to TFLite
4. Save the model as a C array for deployment
"""

import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
import os

def generate_synthetic_data(num_samples=10000, seq_length=100, num_features=6):
    """Generate synthetic sensor data for training."""
    print(f"Generating {num_samples} sequences of length {seq_length} with {num_features} features...")
    
    # Generate normal data (sine waves with some noise)
    t = np.linspace(0, 10, seq_length)
    data = []
    
    for _ in range(num_samples):
        # Each feature is a sine wave with random frequency and phase
        sample = np.zeros((seq_length, num_features))
        for i in range(num_features):
            freq = np.random.uniform(0.5, 2.0)
            phase = np.random.uniform(0, 2 * np.pi)
            noise = np.random.normal(0, 0.1, seq_length)
            sample[:, i] = np.sin(2 * np.pi * freq * t + phase) + noise
        data.append(sample)
    
    return np.array(data, dtype=np.float32)

def create_autoencoder(input_shape):
    """Create a simple autoencoder model."""
    input_layer = layers.Input(shape=input_shape)
    
    # Encoder
    x = layers.Flatten()(input_layer)
    x = layers.Dense(64, activation='relu')(x)
    x = layers.Dense(32, activation='relu')(x)
    x = layers.Dense(16, activation='relu')(x)
    
    # Decoder
    x = layers.Dense(32, activation='relu')(x)
    x = layers.Dense(64, activation='relu')(x)
    x = layers.Dense(np.prod(input_shape), activation='linear')(x)
    output = layers.Reshape(input_shape)(x)
    
    model = models.Model(inputs=input_layer, outputs=output)
    return model

def train_model():
    # Parameters
    seq_length = 100  # Number of time steps
    num_features = 6   # Number of sensor channels (3 accel + 3 gyro)
    batch_size = 32
    epochs = 10
    
    # Generate synthetic data
    x_train = generate_synthetic_data(num_samples=1000, 
                                    seq_length=seq_length, 
                                    num_features=num_features)
    
    # Create and compile the model
    model = create_autoencoder((seq_length, num_features))
    model.compile(optimizer='adam', loss='mse')
    model.summary()
    
    # Train the model
    model.fit(x_train, x_train, 
             batch_size=batch_size, 
             epochs=epochs, 
             validation_split=0.2,
             verbose=1)
    
    return model

def convert_to_tflite(model, quantize=False):
    """Convert the model to TFLite format."""
    converter = tf.lite.TFLiteConverter.from_keras_model(model)
    
    if quantize:
        # Apply dynamic range quantization (reduces model size with minimal accuracy loss)
        converter.optimizations = [tf.lite.Optimize.DEFAULT]
        
        # For full integer quantization (uncomment if needed)
        # converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS_INT8]
        # converter.inference_input_type = tf.int8
        # converter.inference_output_type = tf.int8
    
    tflite_model = converter.convert()
    return tflite_model

def save_as_c_array(tflite_model, output_path):
    """Save the TFLite model as a C array."""
    # Convert to a C source file
    with open(output_path, 'w') as f:
        f.write('#include "model.h"\n\n')
        f.write('// Model data - generated by train_model.py\n')
        f.write('const unsigned char g_model[] = {')
        
        # Write model bytes
        for i, byte in enumerate(tflite_model):
            if i % 12 == 0:
                f.write('\n  ')
            f.write(f'0x{byte:02x}, ')
        
        f.write('\n};\n\n')
        f.write(f'const int g_model_len = {len(tflite_model)};\n')
    
    print(f"Model saved as C array to {output_path}")

if __name__ == "__main__":
    # Create output directory if it doesn't exist
    os.makedirs('output', exist_ok=True)
    
    # Train the model
    print("Training model...")
    model = train_model()
    
    # Convert to TFLite (float32)
    print("\nConverting to TFLite...")
    tflite_model = convert_to_tflite(model, quantize=False)
    with open('output/model.tflite', 'wb') as f:
        f.write(tflite_model)
    
    # Save as C array
    save_as_c_array(tflite_model, 'output/model.h')
    
    # Also create a quantized version
    print("\nCreating quantized model...")
    quant_tflite_model = convert_to_tflite(model, quantize=True)
    with open('output/quant_model.tflite', 'wb') as f:
        f.write(quant_tflite_model)
    
    save_as_c_array(quant_tflite_model, 'output/quant_model.h')
    
    print("\nDone! Copy the appropriate model.h to your Arduino sketch.")
    print("Model sizes:")
    print(f"- Float model: {len(tflite_model)} bytes")
    print(f"- Quantized model: {len(quant_tflite_model)} bytes")
